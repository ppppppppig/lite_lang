import requests
import json

other_prompt = '帮我分析下下面这段故事的寓意：\
    在遥远的宇宙深处，有一个名为阿斯特拉的星球。阿斯特拉是一个充满奇迹的地方，天空中飘浮着闪烁的星辰，大地上有会发光的植物，还有各种奇特的生物。\
    然而，这个星球上有一个传说：每隔一百年，天空中最亮的星辰——“永恒之星”就会消失，整个星球将陷入黑暗，直到有人找到新的光明。\
    这一年，永恒之星再次黯淡了。星球上的居民们陷入了恐慌，因为黑暗意味着寒冷、饥饿和未知的危险。在这个关键时刻，一个名叫莉娅的小女孩站了出来。\
    莉娅是个勇敢而善良的孩子，她相信只要大家团结一心，就一定能够找到新的光明。莉娅决定踏上寻找光明的旅程。\
    她告别了家人和朋友，带着一颗勇敢的心，踏上了旅途。\
    她首先来到了智慧老人的居所。智慧老人告诉她，新的光明藏在“希望之谷”深处的一座神秘水晶塔里。\
    但是，通往希望之谷的路充满了危险，只有最勇敢的人才能到达。莉娅没有退缩，她继续前行。一路上，她遇到了各种困难：巨大的岩石挡住了去路，她用智慧找到了绕过的方法；\
    凶猛的怪兽试图阻止她，她用勇气战胜了它们。在旅途中，莉娅还结识了一些志同道合的朋友：勇敢的战士卡伦、聪明的魔法师艾丽丝和善良的精灵莱恩。\
    他们被莉娅的勇气所打动，决定加入她的旅程，一起寻找新的光明。经过无数的艰难险阻，他们终于来到了希望之谷。谷中弥漫着迷雾，看不清前方的路。\
    莉娅和她的朋友们手拉手，互相鼓励，一步步向前走去。终于，他们看到了那座神秘的水晶塔。塔的入口被一道强大的魔法封印着，只有纯洁的心灵才能解开。\
    莉娅走上前，将手放在水晶塔的封印上。她闭上眼睛，心中充满了对光明的渴望和对朋友的信任。突然，一道温暖的光芒从她的手中散发出来，封印缓缓解开。\
    塔门缓缓打开，里面散发着耀眼的光芒。莉娅和她的朋友们走进塔中，发现了一颗散发着柔和光芒的水晶球。水晶球中蕴含着强大的能量，正是他们寻找的新光明。\
    莉娅将水晶球带回了阿斯特拉星球。当她将水晶球放在永恒之星的位置时，天空中再次闪烁起了明亮的光芒。\
    整个星球被温暖的光辉笼罩，居民们欢呼雀跃，黑暗被驱散了。莉娅和她的朋友们成为了英雄。他们的勇气和友谊拯救了整个星球。\
    从此，阿斯特拉星球上的人们更加团结，他们相信，只要心中有爱，就没有什么是克服不了的。\
    并总结下面的内容,要记得总结：\
    好的，用户的问题是关于NVIDIA Tesla T4显卡上的流式处理器（SM）数量。我需要先理解用户的问题，然后从提供的搜索结果中提取相关信息。\
首先，用户提到的“流式处理器”可能指的是流式多处理器（Streaming Multiprocessors，SM），这是NVIDIA GPU架构中的基本计算单元。每个SM包含多个CUDA核心和其他处理单元，负责并行处理任务。 \
接下来，我需要查看所有相关的搜索结果，寻找关于Tesla T4的SM数量的信息。在提供的搜索结果中，多个文档提到了T4的规格参数：\
网页2（2023年5月25日）提到：“SM count40”，即SM数量为40个。\
网页3（2024年5月8日）提到：“共40个SM(stream multiprocessor)”。\
网页4（2023年1月6日）同样指出：“SM count40”。\
网页5（2024年10月17日）和网页7（2025年4月2日）虽然没有直接提到SM数量，但确认了T4基于TU104核心，与网页2、3、4的信息一致。\
此外，网页6（2023年9月27日）详细列出了T4的规格，包括2560个CUDA核心和320个Tensor核心，但未直接提及SM数量。不过，结合其他文档的信息，可以推断出每个SM的CUDA核心数。例如，网页3提到每个SM有64个CUDA核心，总共有40个SM，因此2560个CUDA核心（64 * 40=2560），这与网页2、3、4、6中的CUDA核心数一致。\
需要确认是否存在不一致的信息。所有相关文档均指出SM数量为40，因此答案应该是40个流式多处理器。同时，补充每个SM的CUDA核心数和总CUDA核心数可以增加回答的完整性，并引用相关网页作为支持。\
最后，确保引用正确的来源编号，如网页2、3、4，并按照用户要求使用[^X]格式引用，每个引用对应不同的文档。避免重复引用同一文档，并确保信息准确无误。\
    随便说点什么把'

test_prompt = "请写一首关于春天的诗,"

# 定义请求参数
url = "http://localhost:8080/generate"
stream_url = "http://localhost:8080/generate_stream"
payload = {
    "prompt": test_prompt,
    "top_p": 0.8,
    "top_k": 20,
    "temperature": 10,
    "do_sample": False,
}

# 普通请求函数（保持原有）
def normal_request():
    print(f"url: {url}")
    response = requests.post(url, json=payload)
    if response.status_code == 200:
        result = response.json()
        print("普通接口结果:", result["result"])
    else:
        print("请求失败，状态码:", response.status_code)

# 新增流式请求函数
def stream_request():
    try:
        # 开启流式模式
        with requests.post(stream_url, json=payload, stream=True) as response:
            if response.status_code != 200:
                print(f"请求失败，状态码: {response.status_code}")
                return

            # 逐块读取内容
            buffer = ""
            for chunk in response.iter_content(chunk_size=1024):
                if chunk:
                    # 解码字节为字符串（参考内容中的编码处理）
                    decoded_chunk = chunk.decode("utf-8")
                    buffer += decoded_chunk
                    ddict = json.loads(decoded_chunk)
                    print(ddict["generated_text"], end="")  # 不换行

    except requests.exceptions.RequestException as e:
        print(f"请求异常: {str(e)}")


# 使用示例
if __name__ == "__main__":

    print("\n--- 流式请求 ---")
    stream_request()
