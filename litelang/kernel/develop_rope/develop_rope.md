[TOC]

### 1.背景

RoPE在大模型中被广泛使用了，它将绝对位置信息编码，并保留了相对位置信息。通过调整基频，也可以比较方便的让大模型支持更长的输入。

[rope.py](./rope.py)是一个简单的旋转式位置编码的实现。

对于该算子来讲，不优化的情况下，其带宽需求如下：

1.构建poos并返回，需要[nd]的防存
2.计算freqs频率，需要[hz // 2]的防存
3.计算angle,需要[nd] + [hz // 2] + [nd, hz//2]的防存
3.计算cos和sin，需要2 * [nd, hz//2]的防存
4.分割输入，需要2 * [nd, nh, hz] 的防存，这一步也可以用view，就不需要这么大了
5.计算两部分旋转，需要2 * （[nd, 1, hz//2] * 2 + 3 * [nd, nh, hz//2]）的防存
6.拼接，需要2*[nd, nh, hz]的防存，这一步也可以用view

算子融合后，带宽需求为：
2 * [nd, nh, hz]的防存


### 2.什么是RoPE，以及其公式推导

绝对位置编码，每个位置都是硬编码，如果有新的位置出现，无法对新位置进行编码

相对位置编码，每个位置没有固定编码，可以变长，但在计算位置a时，会将其他位置相对a的位置引入重新计算，这导致大量的计算开销

RoPE位置编码：每个位置都有一个唯一的角度进行编码，将绝对位置信息编码，又包含了相对位置信息。他的特点是距离远，则点积小，距离近，则点积大。

实际上位置编码就是将位置映射到高维空间中去，并且满足距离越远，点积结果越小，距离越近，点积结果越大的情况

#### 2.1 旋转表示

一个二维坐标(x, y), 使用复数表示为x + jy，而一个旋转表示为$(cos \theta + j sin \theta)$，这个旋转的模长为1，表示坐标（1，0）旋转$\theta$的坐标。

最终可得：
$$
x' = x cose\theta - y sin \theta
y' = x sin\theta + y cos \theta
$$

#### 2.2 如何对一个张量旋转

将这个张量分均分为两部分，第一部分当做x，第二部分当做y，这样产生了很多二维张量，再对这些二维张量进行旋转。


对于查询向量q，和索引张量k，其点积结果为 $ q\dot k = \|\|q\|\| * \|\|k\|\| cos \theta\$, 这样可知，距离越远，$cos \theta$越小，所以旋转位置编码表示会比较有效，

#### 2.4 如何外推

RoPE的设计思想是：不同维度之间的旋转频率应该差异化设计，以捕捉多尺度的位置关系。

一般来说，前面的维度旋转频率快（高频维度），主要捕捉相邻词间的位置关系，后面的维度旋转频率慢（低频维度），主要捕捉远程位置关系。

线性缩放，所有维度一起降频，相邻位置之间的关系差异会变小，难以区分细粒度词序；

非线性缩放（ntk），前面的维度保持震荡频率，捕获相邻位置的位置关系，低频维度频率进一步降低，捕获长程位置关系。